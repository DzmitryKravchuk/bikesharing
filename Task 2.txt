1. Найти бесплатный хостинг и попытаться задеплоить сервис. Если у хостинг не будет бесплатного инстанса БД, то можно использоваться ин-мемори ДБ, сбилдив приложение с новый профилем для такой БД. https://java-master.com/java-%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BD%D0%B0-%D0%B1%D0%B5%D1%81%D0%BF%D0%BB%D0%B0%D1%82%D0%BD%D1%8B%D0%B9-%D1%85%D0%BE%D1%81%D1%82%D0%B8%D0%BD%D0%B3/

2a. Создать GET эндпоинт '/v1/bikesharing/admin/income' возвращающий объект с приблизительным форматом 
{
	incomeDetailsItems: [ {date:"", equpmentNumber: "", equpmentTypeCode: "", amount: 123},... ]
}
. Объект содержит информацию о выручке за период(DAY, MONTH, YEAR), также передаваемый в параметрах. Еще один из параметров запроса - requestPeriodStartDate(LocalDate). Указывает на дату начало периода, если дата не передается, то за начало периода взять текущую дату. Для вычесления старта даты для MONTH, YEAR периодов, округлять не используемые временные показатели в меньшую сторону...т.е. если мы указали тип периода MONTH, а requestPeriodStartDate = 20/06/2020, то округление даст нам начало периода - periodStartDate = 01/06/2020, для YEAR эта же дата трансформируется в 01/01/2020.

2. Создать GET эндпоинт '/v1/bikesharing/admin/income/report' возвращающий файл одного из двух типов(CSV, XLSX). Файл будет содержать сумму выручку за указанный период, крайней строкой в файле должны быть сумма за весь период. + Параметрах запросы такие же как и в п.2а. 

Файл должен содержать хэдер и строки с данными.
Дата(формат 2021/06/20), Номер прокатного оборудования(строка), Тип оборудования(строка), Сумма вырученная за указанную дату(число) <-- Хэдер
2021/06/20 | "123"| "BIKE"   | 123
2021/06/20 | "25" | "SCOOTER"| 12
....
2021/06/21 | "123"| "BIKE"   | 85
           |      |     Итого| 210  (сумма всех строк)<-- последняя строка
Прокат работает не каждый день и соотвественно пустые строки с нерабочими датами не должны быть включены в файл. Сортировка в файле осуществляется в возврастающем порядке, по всем колонкам...сначала дата ASC, затем Номер прокатного оборудования ASC, затем тип ASC

3. Создать кронджобу, которая бы запускалась ежедневно в 22:00. В кроджобе должен формироваться отчет из п.2 за текущий день и отправляться по почте на адреса, указанные в application.yaml файле. Для тестирования использовать mailhog (https://github.com/mailhog/MailHog) поднимать его в докере. 
параметры для настройки почтового сервера прописываются в application.yaml(можно и по-своему реализовать, если найти в интернете примеры)
spring:
  mail:
    host: 127.0.0.1(адрес мэйлхога)
    port: 2525 (порт мэйлхога)
    username:
    password:
    properties:
      mail:
        smtp:
          connectiontimeout: 60000
          timeout: 60000
          auth: false
          starttls:
            enable: false

4. Цель: определять количество накатанного времени у прокатного оборудования, и уведомлять об этом сервис-мена. Один из вариантов: 
Создать новую таблицу (ridden_time) в БД, которая бы содержала колонки id, equipment_item_id, ridden_minutes, datetime(дата начала проката). Таблица хранит информацию об откатанном времени. Создать таблицу maintaince_period (id, service_type_id, interval_in_hours(int)), Таблица сожержит сервисные интервалы. Заполнить ее начальными данными для тестирования. 
последовательность реализации: 
 - По завершению rentOperation асинхронно! отправлять событие в очередь(месседж Брокер) с необходимыми данными. 
 - Создать слушателя для этого события (очереди), по приходу сообщения в который, должна сохраняться новая запись в таблицу ridden_time. см доки и примеры @RabbitListener(queues = "queue-name")
 - создать эндпоинт для выгрузки данных в виде объекта, см следующий подпункт, что должен содержать объект. 
 - создать эндпоинт для формирования репорта (XLSX), который содержит следующие данные:
		 
		Тип прокатного оборудования|номер оборудования| Дата последнего тех обслуживания | Количество накатанных часов с даты последнего обслуживания

		Строки с данными должны быть выделены цветами по следующему принципу:
		- если дата обслуживания отсутсвует и кол-во накатанных часов больше 0, то цвет DANGER
		- если кол-во накатанных часов в пределах до 10% от maintaince_period для сервис типа, то цвет WARNING
		- если кол-во накатанных часов больше либо равно maintaince_period для сервис типа, то цвет DANGER
		
 - создать кронджобу которая бы отправляла репорт из пункта выше на емэйл из проперти файла. 
Для ивентов лучше заюзать какой-нибудь message Broker например RabbitMq, как всегда запустить через докер. Обмен сообщениями в json формате
https://www.onlinetutorialspoint.com/spring-boot/spring-boot-rabbitmq-message-publishing-example.html 
https://dzone.com/articles/rabbitmq-and-spring-boot-integration-with-fault-to
Если не получится, то используй Spring Event 
https://www.baeldung.com/spring-events
https://reflectoring.io/spring-boot-application-events-explained/